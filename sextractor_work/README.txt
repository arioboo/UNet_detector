###---<README.txt>---###

CATALOGNAME—string
Name of the output catalogue.   Ifthe  name  “STDOUT”  is  given  andCATALOGTYPEis  set  toASCII,ASCIIHEAD,ASCIISKYCAT,    orASCIIVOTABLEthe catalogue will bepiped to the standard output (stdout)


CATALOGTYPE—keyword
Format of output catalog:

    ASCII– ASCII table; the simplest, but spaceand time consuming,
    *ASCIIHEAD– asASCII, preceded by a header con-taining information about the content,
    ASCIISKYCAT– SkyCat 
    ASCII format (WCS coordi-nates required),
    ASCIIVOTABLE–  XML-VOTable  format,  togetherwith meta-data,
    FITS1.0– FITS format as inSExtractor1,
    *FITSLDAC– FITS “LDAC” format (the originalimage header is copied).

CHECKIMAGENAME  check.fits      strings(n≤16)   File name for each “check-image”


CHECKIMAGETYPE  NONE
keywords(n≤16)  Type of information to put in the“check-images”:

    NONE– no check-image,IDENTICAL– identical to input image (useful forconverting formats),
    BACKGROUND–  full-resolution  interpolated  back-ground map,
    BACKGROUNDRMS–  full-resolution  interpolated  back-ground noise map,
    MINIBACKGROUND– low-resolution background map,
    MINIBACKRMS–  low-resolution  background  noisemap,
    -BACKGROUND– background-subtracted image,
    FILTERED– background-subtracted filtered im-age (requiresFILTER = Y),
    OBJECTS– detected objects,
    -OBJECTS– background-subtracted image withdetected objects blanked,
    APERTURES–MAGAPERandMAGAUTOintegrationlimits,
    SEGMENTATION– display patches corresponding topixels attributed to each object.













































##--FORMATS AVAILABLE--##

#-<PICKLE>-#
The data format used by pickle is Python-specific. This has the advantage that there are no restrictions imposed by external standards such as JSON or XDR (which can’t represent pointer sharing); however it means that non-Python programs may not be able to reconstruct pickled Python objects.

By default, the pickle data format uses a relatively compact binary representation. If you need optimal size characteristics, you can efficiently compress pickled data.

The module pickletools contains tools for analyzing data streams generated by pickle. pickletools source code has extensive comments about opcodes used by pickle protocols.

There are currently 5 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced.

    Protocol version 0 is the original “human-readable” protocol and is backwards compatible with earlier versions of Python.
    Protocol version 1 is an old binary format which is also compatible with earlier versions of Python.
    Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of new-style classes. Refer to PEP 307 for information about improvements brought by protocol 2.
    Protocol version 3 was added in Python 3.0. It has explicit support for bytes objects and cannot be unpickled by Python 2.x. This is the default protocol, and the recommended protocol when compatibility with other Python 3 versions is required.
    Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data format optimizations. Refer to PEP 3154 for information about improvements brought by protocol 4.

URL:
https://docs.python.org/3/library/pickle.html#data-stream-format


#-<JSON>-#

There are fundamental differences between the pickle protocols and JSON (JavaScript Object Notation):

    JSON is a text serialization format (it outputs unicode text, although most of the time it is then encoded to utf-8), while pickle is a binary serialization format;
    JSON is human-readable, while pickle is not;
    JSON is interoperable and widely used outside of the Python ecosystem, while pickle is Python-specific;
    JSON, by default, can only represent a subset of the Python built-in types, and no custom classes; pickle can represent an extremely large number of Python types (many of them automatically, by clever usage of Python’s introspection facilities; complex cases can be tackled by implementing specific object APIs).

See also

The json module: a standard library module allowing JSON serialization and deserialization. 


#-<MARSHAL>-#

Python has a more primitive serialization module called marshal, but in general pickle should always be the preferred way to serialize Python objects. marshal exists primarily to support Python’s .pyc files.

The pickle module differs from marshal in several significant ways:

    The pickle module keeps track of the objects it has already serialized, so that later references to the same object won’t be serialized again. marshal doesn’t do this.

    This has implications both for recursive objects and object sharing. Recursive objects are objects that contain references to themselves. These are not handled by marshal, and in fact, attempting to marshal recursive objects will crash your Python interpreter. Object sharing happens when there are multiple references to the same object in different places in the object hierarchy being serialized. pickle stores such objects only once, and ensures that all other references point to the master copy. Shared objects remain shared, which can be very important for mutable objects.

    marshal cannot be used to serialize user-defined classes and their instances. pickle can save and restore class instances transparently, however the class definition must be importable and live in the same module as when the object was stored.

    The marshal serialization format is not guaranteed to be portable across Python versions. Because its primary job in life is to support .pyc files, the Python implementers reserve the right to change the serialization format in non-backwards compatible ways should the need arise. The pickle serialization format is guaranteed to be backwards compatible across Python releases provided a compatible pickle protocol is chosen and pickling and unpickling code deals with Python 2 to Python 3 type differences if your data is crossing that unique breaking change language boundary.
